{
  "language": "Solidity",
  "sources": {
    "contracts/TicTacToe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @title TicTacToe\n * @author Lulox\n * @notice A betting TicTacToe contract.\n * @dev Currently for using with one transaction per move,\n *      in a future may be replaced with signatures \n        or other gas efficient mechanism\n */\n\ncontract TicTacToe {\n\tuint256 public gameIdCounter = 0;\n\tuint256 public immutable timeOutValue = 20 minutes;\n\n\tenum GameState {\n\t\tPENDING,\n\t\tPLAYING,\n\t\tPLAYER1WON,\n\t\tPLAYER2WON,\n\t\tTIE,\n\t\tDELETED\n\t}\n\n\tstruct Game {\n\t\taddress player1;\n\t\taddress player2;\n\t\tGameState state;\n\t\tuint256 bet;\n\t\tbool player1Withdrawn;\n\t\tbool player2Withdrawn;\n\t\tuint8[9] board; // 0 (no player): empty, 1 (player 1): X, 2 (player 2): O\n\t\tuint8 moves; // Counter or the number of moves made\n\t\tuint256 lastTimePlayed;\n\t}\n\n\tmapping(uint256 => Game) public games;\n\n\tevent GameCreated(\n\t\tuint256 indexed gameId,\n\t\taddress indexed player1,\n\t\taddress indexed player2,\n\t\tuint256 bet\n\t);\n\tevent GameAccepted(\n\t\tuint256 indexed gameId,\n\t\taddress indexed team1,\n\t\taddress indexed team2\n\t);\n\tevent GameDeleted(uint256 indexed gameId);\n\tevent MoveMade(\n\t\tuint256 indexed gameId,\n\t\taddress indexed player,\n\t\tuint8 position,\n\t\tuint256 lastTimePlayed\n\t);\n\tevent GameFinished(\n\t\tuint256 indexed gameId,\n\t\taddress indexed winner,\n\t\tGameState state\n\t);\n\n\t/* MODIFIERS */\n\n\tmodifier onlyValidMove(uint256 _gameId, uint8 position) {\n\t\t// Store the game in memory to use less storage reads\n\t\tGame memory game = games[_gameId];\n\t\tuint8 currentPlayer = getCurrentPlayer(_gameId);\n\n\t\t// Player should be either player1 or player2, no doubt on that\n\t\trequire(\n\t\t\tmsg.sender == game.player1 || msg.sender == game.player2,\n\t\t\t\"Not a player\"\n\t\t);\n\t\t// Verify if it's your turn or not\n\t\trequire(\n\t\t\t(msg.sender == game.player1 && currentPlayer == 1) ||\n\t\t\t\t(msg.sender == game.player2 && currentPlayer == 2),\n\t\t\t\"Not your turn\"\n\t\t);\n\t\t// Position is within range of board (0 to 8, 9 in total)\n\t\trequire(position < 9, \"Position not valid\");\n\t\t// If the state of the game isn't PLAYING, then you shouldn't be able to play\n\t\trequire(\n\t\t\tgame.state == GameState.PLAYING,\n\t\t\t\"Game hasn't started or already ended!\"\n\t\t);\n\t\t// Require position to be empty, or you can't write there otherwise\n\t\trequire(game.board[position] == 0, \"Position not empty\");\n\t\t// Ensure only players can interact with this game\n\t\t_;\n\t}\n\n\t/* EXTERNAL AND PUBLIC FUNCTIONS */\n\n\tfunction createGame(address _player2) external payable {\n\t\trequire(\n\t\t\t_player2 != msg.sender,\n\t\t\t\"You can't challenge your same address!\"\n\t\t);\n\t\trequire(\n\t\t\t_player2 != address(0),\n\t\t\t\"You can't challenge the zero address!\"\n\t\t);\n\n\t\t// Increase gameIdCounter by one, as a new game is created\n\t\tgameIdCounter++;\n\t\t// Fill the information as a blank game with the data for the Game struct\n\t\tgames[gameIdCounter] = Game({\n\t\t\tplayer1: msg.sender,\n\t\t\tplayer2: _player2,\n\t\t\tstate: GameState.PENDING,\n\t\t\tbet: msg.value,\n\t\t\tplayer1Withdrawn: false,\n\t\t\tplayer2Withdrawn: false,\n\t\t\tboard: [0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t\t\tmoves: 0,\n\t\t\tlastTimePlayed: 0\n\t\t});\n\n\t\t// This event can be used by the frontend to know that something happened and react to it\n\t\temit GameCreated(gameIdCounter, msg.sender, _player2, msg.value);\n\t}\n\n\tfunction acceptGame(uint256 _gameId) external payable {\n\t\tGame memory game = games[_gameId];\n\t\trequire(game.player2 == msg.sender, \"You must be player 2 to accept\");\n\t\trequire(\n\t\t\tgame.state == GameState.PENDING,\n\t\t\t\"Game must be PENDING to be accepted\"\n\t\t);\n\t\t// If the game hasn't been accepted, attempt to accept it (may require payment)\n\t\trequire(\n\t\t\tgame.bet == msg.value,\n\t\t\t\"You haven't sent the required ETH to accept\"\n\t\t);\n\t\t// Set the initial time count to check the timeout\n\t\tgames[_gameId].lastTimePlayed = block.timestamp;\n\n\t\t// Set the game state to PLAYING and emit an event\n\t\tgames[_gameId].state = GameState.PLAYING;\n\t\temit GameAccepted(_gameId, game.player1, game.player2);\n\t}\n\n\tfunction makeMove(\n\t\tuint256 _gameId,\n\t\tuint8 position\n\t) external onlyValidMove(_gameId, position) {\n\t\t// Determine the current Player symbol\n\t\t// 1 is player1, 2 is player2\n\t\tuint8 playerSymbol = games[_gameId].moves % 2 == 0 ? 1 : 2;\n\t\t// Add the corresponding mark in the position of the game board\n\t\tgames[_gameId].board[position] = playerSymbol;\n\t\t// And add 1 to the number of moves made in the game\n\t\tgames[_gameId].moves++;\n\t\tgames[_gameId].lastTimePlayed = block.timestamp;\n\n\t\temit MoveMade(_gameId, msg.sender, position, block.timestamp);\n\t\t// Check if after adding that symbol, a win is achieved, and react to it if that's the case\n\t\tcheckWin(_gameId, position, msg.sender);\n\t}\n\n\t// For when game wasn't accepted and player wants to recover betted ammount\n\tfunction deleteGame(uint256 _gameId) external {\n\t\tGame memory game = games[_gameId];\n\t\trequire(\n\t\t\tmsg.sender == game.player1,\n\t\t\t\"You must be player 1 to delete the request\"\n\t\t);\n\t\trequire(\n\t\t\tgame.state == GameState.PENDING,\n\t\t\t\"Game must be PENDING to be deleted\"\n\t\t);\n\n\t\tgames[_gameId].state = GameState.DELETED;\n\n\t\tpayable(msg.sender).transfer(game.bet);\n\t\temit GameDeleted(_gameId);\n\t}\n\n\t// To incentivize players to keep playing or not quit half a game to not allow the other part to withdraw prize\n\tfunction winByTimeout(uint256 _gameId) external {\n\t\trequire(\n\t\t\tblock.timestamp - games[_gameId].lastTimePlayed > timeOutValue,\n\t\t\t\"Timeout value hasnt been reached yet!\"\n\t\t);\n\t\tgames[_gameId].moves % 2 == 0\n\t\t\t? finishGame(_gameId, games[_gameId].player2)\n\t\t\t: finishGame(_gameId, games[_gameId].player1);\n\t}\n\n\t// Function to withdraw the prize based on game state\n\tfunction withdrawPrize(uint256 _gameId) external {\n\t\tGame storage game = games[_gameId];\n\n\t\t// Ensure the game is in the correct state for prize withdrawal\n\t\trequire(\n\t\t\tgame.state == GameState.PLAYER1WON ||\n\t\t\t\tgame.state == GameState.PLAYER2WON ||\n\t\t\t\tgame.state == GameState.TIE,\n\t\t\t\"Invalid game state for prize withdrawal\"\n\t\t);\n\n\t\t// WITHDRAW RULES FOR PLAYER 1 VICTORY\n\t\tif (game.state == GameState.PLAYER1WON && msg.sender == game.player1) {\n\t\t\trequire(\n\t\t\t\t!game.player1Withdrawn,\n\t\t\t\t\"You have already withdrawn the prize!\"\n\t\t\t);\n\t\t\tgame.player1Withdrawn = true;\n\t\t}\n\n\t\t// WITHDRAW RULES FOR PLAYER 2 VICTORY\n\t\tif (game.state == GameState.PLAYER2WON && msg.sender == game.player2) {\n\t\t\trequire(\n\t\t\t\t!game.player2Withdrawn,\n\t\t\t\t\"You have already withdrawn the prize!\"\n\t\t\t);\n\t\t\tgame.player2Withdrawn = true;\n\t\t}\n\n\t\t// WITHDRAW RULES FOR TIE RESULT\n\t\tif (game.state == GameState.TIE) {\n\t\t\tif (msg.sender == game.player1) {\n\t\t\t\trequire(\n\t\t\t\t\t!game.player1Withdrawn,\n\t\t\t\t\t\"You have already withdrawn the prize!\"\n\t\t\t\t);\n\t\t\t\tgame.player1Withdrawn = true;\n\t\t\t} else if (msg.sender == game.player2) {\n\t\t\t\trequire(\n\t\t\t\t\t!game.player2Withdrawn,\n\t\t\t\t\t\"You have already withdrawn the prize!\"\n\t\t\t\t);\n\t\t\t\tgame.player2Withdrawn = true;\n\t\t\t}\n\t\t}\n\n\t\t// Calculate and transfer the prize based on the game state\n\t\tuint256 prize = calculatePrize(_gameId);\n\t\trequire(prize > 0, \"Invalid prize amount\");\n\n\t\t// Transfer the prize to the player\n\t\tpayable(msg.sender).transfer(prize);\n\t}\n\n\t/* INTERNAL FUNCTIONS */\n\n\tfunction checkWin(\n\t\tuint256 _gameId,\n\t\tuint8 _position,\n\t\taddress _player\n\t) internal {\n\t\t// Store the game in memory to use less storage reads\n\t\tGame memory game = games[_gameId];\n\t\t// Check if board is complete and a tie should be declared\n\t\t// If all moves were used and no victory was gotten\n\t\tif (game.moves == 9) {\n\t\t\t// Set the game as a Tie and finish it so prizes can be withdrawn\n\t\t\tfinishGame(_gameId, address(0));\n\t\t}\n\n\t\t// Get current player symbol\n\t\tuint8 playerSymbol = games[_gameId].moves % 2 == 0 ? 2 : 1; // Order is reverted because a moves++ is triggered before calling this internal function.\n\n\t\tuint8 row = _position / 3;\n\t\tuint8 col = _position % 3;\n\n\t\t// Check row\n\t\tif (\n\t\t\tgame.board[row * 3] == playerSymbol &&\n\t\t\tgame.board[row * 3 + 1] == playerSymbol &&\n\t\t\tgame.board[row * 3 + 2] == playerSymbol\n\t\t) {\n\t\t\tfinishGame(_gameId, _player);\n\t\t}\n\n\t\t// Check column\n\t\tif (\n\t\t\tgame.board[col] == playerSymbol &&\n\t\t\tgame.board[col + 3] == playerSymbol &&\n\t\t\tgame.board[col + 6] == playerSymbol\n\t\t) {\n\t\t\tfinishGame(_gameId, _player);\n\t\t}\n\n\t\t// Check diagonals\n\t\tif (\n\t\t\t(row == col || row + col == 2) &&\n\t\t\t((game.board[0] == playerSymbol &&\n\t\t\t\tgame.board[4] == playerSymbol &&\n\t\t\t\tgame.board[8] == playerSymbol) ||\n\t\t\t\t(game.board[2] == playerSymbol &&\n\t\t\t\t\tgame.board[4] == playerSymbol &&\n\t\t\t\t\tgame.board[6] == playerSymbol))\n\t\t) {\n\t\t\tfinishGame(_gameId, _player);\n\t\t}\n\t}\n\n\tfunction finishGame(uint256 gameId, address winner) internal {\n\t\tGame storage game = games[gameId];\n\n\t\t// Ensure the game is in the PLAYING state before finishing\n\t\trequire(\n\t\t\tgame.state == GameState.PLAYING,\n\t\t\t\"Game is not in PLAYING state\"\n\t\t);\n\n\t\t// Determine the result based on the winner and update game state accordingly\n\t\tif (winner == address(0)) {\n\t\t\t// It's a tie\n\t\t\tgame.state = GameState.TIE;\n\t\t} else if (winner == game.player1) {\n\t\t\t// Player 1 won\n\t\t\tgame.state = GameState.PLAYER1WON;\n\t\t} else if (winner == game.player2) {\n\t\t\t// Player 2 won\n\t\t\tgame.state = GameState.PLAYER2WON;\n\t\t} else {\n\t\t\t// Winner address is not valid\n\t\t\trevert(\"Invalid winner address\");\n\t\t}\n\n\t\t// Emit GameFinished event\n\t\temit GameFinished(gameId, winner, game.state);\n\t}\n\n\t// Function to calculate the prize based on the game state\n\tfunction calculatePrize(uint256 _gameId) internal view returns (uint256) {\n\t\tGame storage game = games[_gameId];\n\t\tuint256 totalBet = game.bet * 2; // Total amount bet in the game\n\n\t\tif (game.state == GameState.PLAYER1WON) {\n\t\t\treturn totalBet;\n\t\t} else if (game.state == GameState.PLAYER2WON) {\n\t\t\treturn totalBet;\n\t\t} else if (game.state == GameState.TIE) {\n\t\t\t// In the case of a tie, split the total bet equally between players\n\t\t\treturn game.bet;\n\t\t} else {\n\t\t\t// Invalid game state\n\t\t\trevert(\"Invalid game state\");\n\t\t}\n\t}\n\n\t/* VIEW AND PURE FUNCTIONS */\n\n\tfunction getCurrentPlayer(uint256 _gameId) public view returns (uint8) {\n\t\treturn games[_gameId].moves % 2 == 0 ? 2 : 1;\n\t}\n\n\tfunction getNumberOfMoves(uint256 _gameId) public view returns (uint8) {\n\t\treturn games[_gameId].moves;\n\t}\n\n\tfunction getBoard(uint256 _gameId) external view returns (uint8[9] memory) {\n\t\treturn games[_gameId].board;\n\t}\n\n\tfunction getGameState(uint256 _gameId) public view returns (GameState) {\n\t\treturn games[_gameId].state;\n\t}\n\n\tfunction getLastTimePlayed(uint256 _gameId) public view returns (uint256) {\n\t\treturn games[_gameId].lastTimePlayed;\n\t}\n\n\tfunction hasPlayer1WithdrawnPrize(\n\t\tuint256 _gameId\n\t) public view returns (bool) {\n\t\treturn games[_gameId].player1Withdrawn;\n\t}\n\n\tfunction hasPlayer2WithdrawnPrize(\n\t\tuint256 _gameId\n\t) public view returns (bool) {\n\t\treturn games[_gameId].player2Withdrawn;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}